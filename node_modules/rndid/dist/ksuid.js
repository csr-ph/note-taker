"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var baseX = require("base-x");
function Base62() {
    var alpha = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return baseX(alpha);
}
var base62 = Base62();
// KSUID's epoch starts more recently so that the 32-bit number space gives a
// significantly higher useful lifetime of around 136 years from March 2017.
// This number (14e8) was picked to be easy to remember.
var epochStamp = 1400000000 | 0, // number | 0 forces the number into a 32bit
// Timestamp is a uint32
timestampLengthInBytes = 4, 
// Payload is 16-bytes
payloadLengthInBytes = 16, 
// KSUIDs are 20 bytes when binary encoded
byteLength = timestampLengthInBytes + payloadLengthInBytes, 
// The length of a KSUID when string (base62) encoded
stringEncodedLength = 27, 
// A string-encoded maximum value for a KSUID
maxStringEncoded = "aWgEPTl1tmebfsQzFP4bxwgy80V";
function genPayload() {
    return crypto_1.randomBytes(payloadLengthInBytes);
}
function now(time) {
    return (time - epochStamp) | 0;
}
function int32ToBuffer(num) {
    var buf = Buffer.allocUnsafe(4);
    buf.writeInt32BE(num, 0);
    return buf;
}
function newKSUID(seconds) {
    var t;
    if (seconds) {
        t = seconds | 0;
    }
    else {
        t = (new Date().getTime() / 1000) | 0;
    }
    var timestamp = int32ToBuffer(now(t));
    var payload = genPayload();
    var uid = Buffer.concat([timestamp, payload]);
    return base62.encode(uid);
}
function parse(uid) {
    var k = base62.decode(uid);
    var l = k.length;
    var time = Buffer.allocUnsafe(4);
    var payload = Buffer.allocUnsafe(16);
    for (var i = 0; i < l; i++) {
        if (i < 4) {
            time[i] = k[i];
        }
        else {
            payload[i - 4] = k[i];
        }
    }
    var timestamp = (time.readInt32BE(0, true) + epochStamp);
    var milliseconds = timestamp * 1000;
    return {
        time: new Date(milliseconds).toString(),
        timestamp: timestamp,
        payload: payload
    };
}
exports.parse = parse;
/**
 * generate a KSUID
 * @param seconds seconds with with which to generate KSUID
 */
function ksuid(seconds) {
    return newKSUID(seconds);
}
exports.default = ksuid;
